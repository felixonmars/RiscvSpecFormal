
module Main where

import Simulator.All
import HaskellTarget as T

import qualified Data.HashMap as M
import qualified Data.Vector as V
import qualified Data.BitVector as BV

import Data.String
import Data.List (find)
import Data.Maybe (isJust)
import Control.Monad
import Data.IORef
import System.Exit
import System.IO
import System.Random (randomIO)
import System.Environment (getArgs)
import Text.Read

handle :: Handle
handle = stdout

timeout :: Int
timeout = 50000

isa_size :: Int
isa_size = snd T.kami_model

regfiles :: [T.RegFileBase]
regfiles = fst $ fst T.kami_model

basemod :: T.BaseModule
basemod = snd $ fst T.kami_model

mem_file :: String
mem_file = "proc_core_mem_reg_file"

float_file :: String
float_file = "proc_core_float_reg_file"

int_file :: String
int_file = "proc_core_int_data_reg"

-- 0x80000000
offset :: Int
offset = 2147483648

meths :: IORef Int -> IORef Int -> [(String, Val -> FileState -> M.Map String Val -> IO Val)]
meths steps counter =
  [("proc_core_pc", proc_core_meth steps counter),
   ("proc_core_ext_interrupt_pending", io_meth steps counter),
   ("proc_core_exception", proc_core_exception steps counter)]

proc_core_exception :: IORef Int -> IORef Int -> Val -> FileState -> M.Map String Val -> IO Val
proc_core_exception steps counter v filestate regstate =
  let exception = boolCoerce v in
    if exception then do hPutStrLn handle "BAD BAD BAD BAD BAD: exception when attempting to execute stale memory!!!"
                         hPutStrLn stderr "BAD BAD BAD BAD BAD: exception when attempting to execute stale memory!!!"
                         exitFailure
    else return $ BVVal BV.nil

io_meth :: IORef Int -> IORef Int -> Val -> FileState -> M.Map String Val -> IO Val
io_meth steps counter v filestate regstate = do
   args <- getArgs
   if isJust $ find (\arg -> arg == "--enable-ext-interrupts") args then do
     putStrLn "external interrupts enabled"
     result <- randomIO
     if result then do putStrLn "signalling an external interrupt"; return tt else return tt
     return $ BoolVal result
   else return $ BoolVal False

proc_core_meth :: IORef Int -> IORef Int -> Val -> FileState -> M.Map String Val -> IO Val
proc_core_meth steps counter v filestate regstate = do
    tohost_addr <- getArgVal "tohost_address" isa_size
    n <- readIORef counter
    when (n > timeout) $ do
        hPutStrLn handle "TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT"
        hPutStrLn stderr "TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT"
        exitFailure
    writeIORef counter (n+1)
    currSteps <- readIORef steps
    when (currSteps > 0) (writeIORef steps (currSteps-1))
    case M.lookup mem_file (arrs filestate) of
        Nothing -> error $ "File " ++ mem_file ++ " not found."
        Just v -> let val = v V.! (fromIntegral $ BV.nat $ bvCoerce tohost_addr) in 
            if bvCoerce val == 1 then do
                hPutStrLn handle "Passed"
                hPutStrLn stderr "Passed"
                exitSuccess

            else if bvCoerce val > 1 then do
                    hPutStrLn handle "FAILED FAILED FAILED FAILED FAILED FAILED FAILED FAILED FAILED"
                    hPutStrLn stderr "FAILED FAILED FAILED FAILED FAILED FAILED FAILED FAILED FAILED"
                    exitFailure
            else do
                io_stuff
                return tt

    where 

    io_stuff = do
        currSteps <- readIORef steps
        interactive <- interactive_mode
        when (interactive && currSteps == 0) $ do
        putStr "% "
        hFlush stdout
        input <- getLine
        case words input of
            ["Step",num] -> case readMaybe num of
                Nothing -> do
                    putStrLn "Formatting error."
                    io_stuff
                Just n -> writeIORef steps n
            [reg] -> do 
                print_reg regstate $ "proc_core_" ++ reg
                io_stuff
            ["Float",addr] -> do
                case hex_to_maybe_integer_str addr of
                    Just n -> print_file_reg filestate float_file $ fromInteger n
                    Nothing -> putStrLn "Formatting error."
                io_stuff
            ["Int",addr] -> do
                case hex_to_maybe_integer_str addr of
                    Just n -> case n == 0 of
                        True -> case M.lookup int_file (files filestate) of
                            Nothing -> putStrLn $ "File " ++ int_file ++ " not found."
                            Just r -> let k = kind r in putStrLn $ ppr_hex $ defVal k
                        False -> print_file_reg filestate int_file $ fromInteger n
                    Nothing -> putStrLn "Formatting error."
                io_stuff
            ["Mem",addr] -> do
                case hex_to_maybe_integer_str addr of
                    Just n -> print_file_reg filestate mem_file $ fromInteger n - offset
                    Nothing -> putStrLn "Formatting error."
                io_stuff
            [] -> io_stuff
            _ -> do
                putStrLn "Formatting error."
                io_stuff

main :: IO()
main = do
    counter <- newIORef 0
    steps <- newIORef 0
    simulate_module 0 round_robin_rules (map fst $ T.getRules basemod) (meths steps counter) regfiles basemod
    return ()
